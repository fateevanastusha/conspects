/*
* WEBHOOK - способ оповещения лкиента о прозоедшем в системе собтии с помощью пользовательских
* обрвтных вызовов по HTTP. Запускается, когда в ситеме происходит какое-то событие. Когда происходит
* это событие, сервер создает HTTP-вызов и отправляет его на адрес, указанный клиентом для получения
* вебхуков. Альтернатива API.
* Можно настроить так, что события на одних сайтах вызывают действия на другом.
*
* т.к. API работает по принципу "сделай запрос - получи ответ", то вебхуки как подписка на обновления
* для определенных событий.  (Он сам оповещает клиента, если нужно). Пользователь сам указывает, о
* каких событиях нужно оповещать и реагировать.
*
* Обычно webhook отпрлавяет в формате POST запроса.
*
* Webhook
* - клиент формирует урлы для запроса
* - вебхук использует урлы, когда нужно
*
* Webhook состоит из:
* - переменных
* - данных, которые всегда меняются
*
* Примеры использования:
*
* GITHUB - использует вебхуки, чтобы оповещать пользователей о каких-то событиях (новых сообщениях, выпущенных
* обновлениях и тд
*
* Способы обезопасить вебхуки:
* 1. Basic auth
* 2. token
* 3. https
* 4. HMAC
*
* При использовании вебхука
* - возможна потеря данных
* - перегрузка (ddos)
*
* Вебхуки лучше использовать только для уведомления изменения состояния на сервере, не надо отправлять через них данные.
* */

/*
* REACT HOOKS
*
* - появилась в 16.8
* - позволяет использовать только React компоненты
* */

/*
1. USESTATE
- позволит работать в функциональных компонентах
const [isActive, setIsActive] = useState(false)
isActive - текущее состояние
setIsActive - указать текущее состояние
*/

/*
2. USEEFFECT

- позволяет реализовать lifecycle хуки в функциональных компонентах
useEffect( ()=>{}, [СЮДА ПЕРЕДАВАТЬ ЗАВИСИМОСТИ, ЕСЛИ НЕ ОТДАТЬ НИЧЕГО- ТО РЕАГИРОВАТЬ БУДЕТ НА ЛЮБОЕ ИЗМЕНЕНИЕ СОСТОЯНИЯ])
1 аргумент - callback
2 аргумент - список зависимостей, на которые откликается useEffect

на каждое изменение состояния он будет срабаывать (любое)
является аналогом хука componentDidMount,который вызывается тогда, когда HTML шаблон готов для дальнейшей работы.
если передать в массив (2 аргумент, в сам массив) какое-то состояние, то хук будет срабатывать, когда это состояние меняется.

например,
*/

/*
3. USECONTEXT
- позволяет получить доступ к значениям контекста внутри функционального компонента. Позволяет передавать данные между
компонентами без пропсов.
export const Context = React.createContext()

оборачиваем весь компонент в контекст
<Context value = {{ СЮДА ПЕРЕДАЕМ ФУНКЦИИ }}> </Context>

используем контекст

const { ЗДЕСЬ ПЕРЕДАННЫЕ ФУНКЦИИ } = useContext(Context)

особенно полезно, когда нужно передать глобальные данные, такие как тема приложения или текущий пользователь, между разными
частями приложения
*/

/*
4. USEREDUCER
- служит для упрощение поддержки приложения. Помогает не хранить все методы, меняющие state. Позволяет вынести логику в отдельный файл.

создаем файл reducer :

export default function (state, action) {
    switch (action.type) {
        case "on" :
           return action.payload
        default :
            return state
}

- это дефолтные требования редьюсера.
state - состояние
action -

const [state, dispatch] = useReducer(reducer, [false])

state - состояние
dispatch - функция, которая изменяет состояние стейта
reducer - это та дефолтная функция
[] - значение начального state, кот. мы хотим использовать

dispatch ({
 type : "on",
 payload : true
})

таким образом, вынесли логику переключения в другой файл.
*/